#!/usr/bin/env python3.6
"""Simple program to deploy Concourse pipelines."""

import argparse
import logging
import sys

from pathlib import Path
from subprocess import CalledProcessError, PIPE, run
from typing import List

L = logging.getLogger(__name__)
L.addHandler(logging.NullHandler())

DEBIAN_REPOS = [
    'opx-alarm',
    'opx-base-model',
    'opx-common-utils',
    'opx-cps',
    'opx-db-sql',
    'opx-logging',
    'opx-nas-acl',
    'opx-nas-common',
    'opx-nas-daemon',
    'opx-nas-interface',
    'opx-nas-l2',
    'opx-nas-l3',
    'opx-nas-linux',
    'opx-nas-ndi',
    'opx-nas-ndi-api',
    'opx-nas-qos',
    'opx-northbound',
    'opx-pas',
    'opx-platform-config',
    'opx-sai-vm',
    'opx-sdi-sys',
    'opx-snmp',
    'opx-tmpctl',
    'opx-tools',
]


def pipeline_cmd(team: str, pipeline: str, config: str) -> List[str]:
    cmd = ['fly', '-t', team, 'set-pipeline', '-n',
           '--pipeline', pipeline,
           '--config', config]
    if 'opx-debian' in config:
        cmd += ['--var', f'repo={pipeline}']
    return cmd


def set_pipeline(cmd: List[str]):
    result = run(cmd, stdout=PIPE, stderr=PIPE, universal_newlines=True)
    try:
        result.check_returncode()
    except CalledProcessError as e:
        L.error(f'Command {e.cmd} returned non-zero exit status {e.returncode}.')
        L.error(result.stderr)
        sys.exit(1)
    L.info(result.stdout)


def main():
    parser = argparse.ArgumentParser(description=__doc__)

    parser.add_argument(
        '-v', '--verbose',
        help='log debug messages',
        action='store_const',
        dest='loglevel',
        const=logging.DEBUG,
        default=logging.INFO,
    )

    parser.add_argument(
        '--team', '-t',
        default='prod',
        help='Concourse team to use.',
    )

    parser.add_argument(
        'pipeline',
        help='Pipeline to deploy. Can be "all".',
    )

    args = parser.parse_args()
    logging.basicConfig(level=args.loglevel)
    L.debug(args)

    if args.pipeline == 'all':
        L.info('Not implemented yet.')
        for p in Path('pipelines').glob('*.yaml'):
            pass
    elif args.pipeline == 'opx-debian':
        pipeline = Path(f'pipelines/{args.pipeline}.yaml')
        for r in DEBIAN_REPOS:
            set_pipeline(pipeline_cmd(args.team, r, str(pipeline)))
    else:
        pipeline = Path(f'pipelines/{args.pipeline}.yaml')
        if not pipeline.exists():
            L.error(f'Pipeline configuration file {pipeline} does not exist.')
            L.error('Use "opx-debian" for any Debian package pipeline.')
            sys.exit(1)
        set_pipeline(pipeline_cmd(args.team, args.pipeline, str(pipeline)))


if __name__ == '__main__':
    main()
